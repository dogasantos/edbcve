#!/usr/bin/env python3
"""
Exploit-DB CVE Processor
Fetches the Exploit-DB CSV, filters for CVE entries, and generates a clean JSON output.
"""

import csv
import json
import re
import requests
from datetime import datetime
from collections import defaultdict

# Exploit-DB CSV URL
EXPLOITDB_CSV_URL = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"

# CVE pattern regex
CVE_PATTERN = re.compile(r'CVE-\d{4}-\d{4,7}', re.IGNORECASE)

def fetch_exploitdb_csv():
    """Download the Exploit-DB CSV file."""
    print("Downloading Exploit-DB CSV...")
    response = requests.get(EXPLOITDB_CSV_URL, timeout=60)
    response.raise_for_status()
    return response.text

def parse_csv_to_cve_dict(csv_content):
    """Parse CSV and organize exploits by CVE ID."""
    cve_dict = defaultdict(list)
    
    # Parse CSV
    csv_reader = csv.DictReader(csv_content.splitlines())
    
    total_exploits = 0
    cve_exploits = 0
    
    for row in csv_reader:
        total_exploits += 1
        
        # Extract CVE IDs from the 'codes' column and description
        cve_ids = set()
        
        # Check 'codes' column (if it exists)
        if 'codes' in row and row['codes']:
            cve_ids.update(CVE_PATTERN.findall(row['codes']))
        
        # Check description
        if 'description' in row and row['description']:
            cve_ids.update(CVE_PATTERN.findall(row['description']))
        
        # If CVEs found, add to dictionary
        if cve_ids:
            cve_exploits += 1
            exploit_entry = {
                "edb_id": row.get('id', ''),
                "description": row.get('description', '').strip('"'),
                "date": row.get('date', ''),
                "author": row.get('author', ''),
                "type": row.get('type', ''),
                "platform": row.get('platform', ''),
                "port": row.get('port', ''),
                "file": row.get('file', ''),
                "urls": [f"https://www.exploit-db.com/exploits/{row.get('id', '')}"]
            }
            
            # Add to each CVE ID found
            for cve_id in cve_ids:
                cve_id_upper = cve_id.upper()
                cve_dict[cve_id_upper].append(exploit_entry)
    
    print(f"Total exploits processed: {total_exploits}")
    print(f"Exploits with CVE references: {cve_exploits}")
    print(f"Unique CVEs found: {len(cve_dict)}")
    
    return cve_dict

def generate_output_json(cve_dict):
    """Generate the final JSON output."""
    output = {
        "metadata": {
            "generated_at": datetime.utcnow().isoformat() + "Z",
            "source": "Exploit-DB",
            "source_url": EXPLOITDB_CSV_URL,
            "total_cves": len(cve_dict),
            "total_exploits": sum(len(exploits) for exploits in cve_dict.values())
        },
        "cves": {}
    }
    
    # Convert defaultdict to regular dict and sort by CVE ID
    for cve_id in sorted(cve_dict.keys()):
        output["cves"][cve_id] = {
            "cve_id": cve_id,
            "exploit_count": len(cve_dict[cve_id]),
            "exploits": cve_dict[cve_id]
        }
    
    return output

def main():
    """Main execution function."""
    try:
        # Fetch CSV
        csv_content = fetch_exploitdb_csv()
        
        # Parse and organize by CVE
        cve_dict = parse_csv_to_cve_dict(csv_content)
        
        # Generate output JSON
        output = generate_output_json(cve_dict)
        
        # Write to file
        output_file = "exploitdb_cves.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(output, f, indent=2, ensure_ascii=False)
        
        print(f"\n+ Successfully generated {output_file}")
        print(f"  - Total CVEs: {output['metadata']['total_cves']}")
        print(f"  - Total Exploits: {output['metadata']['total_exploits']}")        
        return 0
        
    except Exception as e:
        print(f"âœ— Error: {e}")
        import traceback
        traceback.print_exc()
        return 1

if __name__ == "__main__":
    exit(main())
